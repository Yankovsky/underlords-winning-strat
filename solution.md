Что я попытался сделать:
1. Написал скрипт на js
2. Не смог быстро найти либу для генерации комбинаций, а сам писать не хотел
3. Очевидно, что такая либа должна уметь выдавать комбинации по запросу/итератором, а не сохранять их сразу в огромный массив
4. Та либа, которую я смог найти, на каком-то большом количестве комбинаций просто завершала работу
5. Я расстроился и решил попробовать python, потому что на нём делают data science и обработку данных, также, в нём есть из коробки пакет, который делает комбинации итератором itertools
6. Помучался с новым для себя языком, но написал скрипт, который работает sequential.py
7. Он работал намного быстрее, чем js, но всё равно недостаточно быстро для моей задачи
8. Попробовал распараллелить вычисления с помощью встроенной либы multiprocessing, получилось ускорить, но не получилось всё распараллелить
9. Написал доки и сделал 2 файла sequential и parallel

Мне кажется, я не туда копаю и есть математическое решение, для которого надо составить систему неравенств/уравнений и потом прогнать линейную оптимизацию

Что можно сделать, чтобы ускорить текущее решение:
- Сделать процессов по количеству ядер, получать новую кобминацию,
отправлять её незанятому процессу, считать количество альянсов,
если получилось больше, чем текущее лучшее решение, то перезаписывать,
брать следующую комбинацию и прогонять снова, в конце по всем процессам собрать их результаты и смёрджить лучшие
- Добавить мемоизацию для проверенных комбинаций, не считать их заново, а отдавать количество альянсов;
здесь проблема в том, что кончится память скорее всего, зато все герои отсортированны и вообще должно быть удобно
- Ничего не оптимизировать и прогнать это на крутом серваке на Digital Ocean
- Переписать на C или R